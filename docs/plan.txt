for standalone tests:

 + on enter, on exit actions
 * conditions
 * multistate support
 * load scxml
 * store/load context - async db context loader


 * handle 2 different statechart in amqp event processing

 * async events processing in aihttp event loop
   - keep events execution order
   - lock sc on event processing
   - wait for sc ready (not locked)

 * mm server
   - internal asyncio event loop
   - rabbitmq messaging (aioqp)
   - utilize all code from previous approach
   - mm client

 * activities
   - asynchronous, right on event processing
   - decoupled through messaging - rabbitmq
   - decoupled through mm client/server


 • asynchronous processor engine
 • use arbitrary storage for SC
 • memory SC storage
 • DB SC storage
 • lock SC on get from storage. ensure single-use
 • load SC into internal python structures
 • simple FSM processor
 • parallel states
 • history states
 • get events from abstract source
 • rabbitmq event source
 • memory event source
 • unload SC to storage
 • broadcast events
 • load SC from storage by expected_events
 • targeted events
 • custom SC storage based on DB SC storage
 • unit of work for SC transaction
 • activities
 • activity packages, registration, use
 • scxml variables assignment
 • scxml logging
 • sc versioning
 • celery tasks activity
 • send events from activities
 • conditional transitions
 • transition with activity without target
 • calc test project based on mixmorph
 • ss payment engine based on mixmorph
 • issues engine based on mixmorph
 • performance testing
 • docker service
